/*
 * Tomitribe Confidential
 *
 * Copyright Tomitribe Corporation. 2015
 *
 * The source code for this program is not published or otherwise divested 
 * of its trade secrets, irrespective of what has been deposited with the 
 * U.S. Copyright Office.
 */
package org.tomitribe.churchkey;

import org.junit.Assert;
import org.junit.Test;

import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class RsaTest extends Assert {

    @Test
    public void test() throws Exception {

        final int rsaBits = 1024;
        final int shaBits = 256;

        final Resource resource = Resource.resource(rsaBits, shaBits);

        final KeyFactory rsa = KeyFactory.getInstance("RSA");
        final RSAPrivateKey privateKey = (RSAPrivateKey) rsa.generatePrivate(new PKCS8EncodedKeySpec(resource.bytes("private.pkcs8.der")));
        final RSAPublicKey publicKey = (RSAPublicKey) rsa.generatePublic(new X509EncodedKeySpec(resource.bytes("public.pkcs8.der")));

        final Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(privateKey);
        signature.update(resource.bytes("data.txt"));
        final byte[] sign = signature.sign();


        signature.initVerify(publicKey);
        signature.update(resource.bytes("data.txt"));
        assertTrue(signature.verify(sign));
    }
    @Test
    public void test3() throws Exception {

        final int rsaBits = 1024;
        final int shaBits = 256;

        final Resource resource = Resource.resource(rsaBits, shaBits);

        final KeyFactory rsa = KeyFactory.getInstance("RSA");
        final RSAPrivateKey privateKey = (RSAPrivateKey) rsa.generatePrivate(new PKCS8EncodedKeySpec(resource.bytes("private.pkcs8.der")));
        final RSAPublicKey publicKey = (RSAPublicKey) rsa.generatePublic(new X509EncodedKeySpec(resource.bytes("public.pkcs8.der")));

        final Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(privateKey);
        signature.update(resource.bytes("data.txt"));
        final byte[] sign = signature.sign();
        final String s = Base64.getEncoder().encodeToString(sign);
        assertEquals(new String(resource.bytes("signature.txt")), s);

        signature.initVerify(publicKey);
        signature.update(resource.bytes("data.txt"));
        assertTrue(signature.verify(sign));
    }

    @Test
    public void testOpenSSHKeys() throws Exception {
        final Scenario scenario = new Scenario(1024, 256);
        final PublicKey publicKey = Keys.readPublicKey(scenario.bytes("public.pkcs8.der"));
        assertSignatureVerification(scenario, (RSAPublicKey) publicKey);
    }

    /**
     * A digital signature was generated by OpenSSL.  We use the provided public key
     * to attempt to verify that digital signature.  If we cannot, we didn't properly
     * read the RSA Public Key
     */
    private static void assertSignatureVerification(final Scenario scenario, final RSAPublicKey rsaPublicKey) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException, IOException {
        final Signature signature = Signature.getInstance(String.format("SHA%swithRSA", scenario.getShaBits()));
        signature.initVerify(rsaPublicKey);
        signature.update(scenario.data());
        assertTrue(signature.verify(scenario.signature()));
    }


}
